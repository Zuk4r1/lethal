import requests
import re
import json
import random
import itertools
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from colorama import Fore, Style
from core.utils import guardar_resultado

USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (Linux; Android 13; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36",
    "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/18.18363",
    "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)",
    "Mozilla/5.0 (compatible; Bingbot/2.0; +http://www.bing.com/bingbot.htm)",
    "Mozilla/5.0 (Linux; Android 10; SM-A205U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Mobile Safari/537.36",
    "Mozilla/5.0 (iPad; CPU OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1"
]

def explotar_idor(
    url,
    metodo,
    headers_str=None,
    proxy=None,
    output=None,
    silent=False,
    body=None,
    id_fuzz=None,
    guardar_respuesta=False,
    param_fuzz=None,
    proxies_list=None,
    cookies_str=None,
    auths=None, # lista de tokens/cabeceras de autenticación
    timeout=10,
    retries=2,
    legit_user_headers=None, # headers de usuario legítimo para comparación diferencial
    legit_user_body=None
):
    headers = {}
    proxies = {"http": proxy, "https": proxy} if proxy else None

    # Parsear encabezados personalizados
    if headers_str:
        for linea in headers_str.split(";"):
            if ":" in linea:
                clave, valor = linea.split(":", 1)
                headers[clave.strip()] = valor.strip()
    # Randomizar User-Agent si no está definido
    if "User-Agent" not in headers:
        headers["User-Agent"] = random.choice(USER_AGENTS)
    # Cookies
    cookies = {}
    if cookies_str:
        for c in cookies_str.split(";"):
            if "=" in c:
                k, v = c.split("=", 1)
                cookies[k.strip()] = v.strip()

    # Generar combinaciones de fuzzing
    urls_a_probar = [url]
    if id_fuzz:
        urls_a_probar = []
        for id_val in id_fuzz:
            urls_a_probar.append(re.sub(r"\d+", str(id_val), url, count=1))
    if param_fuzz:
        param_names = list(param_fuzz.keys())
        param_values = list(param_fuzz.values())
        combos = list(itertools.product(*param_values))
        urls_a_probar = []
        parsed = urlparse(url)
        base_query = parse_qs(parsed.query)
        for combo in combos:
            q = base_query.copy()
            for i, v in enumerate(combo):
                q[param_names[i]] = [str(v)]
            new_query = urlencode(q, doseq=True)
            new_url = urlunparse(parsed._replace(query=new_query))
            urls_a_probar.append(new_url)

    hallazgos = []
    logs = []
    for idx, url_actual in enumerate(urls_a_probar):
        # Rotar proxy si hay lista
        if proxies_list:
            proxy = random.choice(proxies_list)
            proxies = {"http": proxy, "https": proxy}
        # Rotar autenticación si hay lista
        if auths:
            auth_header = random.choice(auths)
            headers.update(auth_header)
        for intento in range(retries):
            try:
                req_args = {
                    "headers": headers,
                    "proxies": proxies,
                    "verify": False,
                    "timeout": timeout,
                    "cookies": cookies if cookies else None,
                    "allow_redirects": True
                }
                # Fuzzing de parámetros en body
                req_body = body
                if metodo.upper() in ["POST", "PUT"] and body:
                    if param_fuzz:
                        try:
                            body_json = json.loads(body)
                            for param, values in param_fuzz.items():
                                body_json[param] = random.choice(values)
                            req_args["json"] = body_json
                        except Exception:
                            for param, values in param_fuzz.items():
                                req_body = re.sub(f"{param}=[^&]*", f"{param}={random.choice(values)}", body)
                            req_args["data"] = req_body
                    else:
                        try:
                            req_args["json"] = json.loads(body)
                        except Exception:
                            req_args["data"] = body

                # Soporte para métodos personalizados
                metodo_real = metodo.upper()
                if metodo_real == "GET":
                    resp = requests.get(url_actual, **req_args)
                elif metodo_real == "POST":
                    resp = requests.post(url_actual, **req_args)
                elif metodo_real == "PUT":
                    resp = requests.put(url_actual, **req_args)
                elif metodo_real == "DELETE":
                    resp = requests.delete(url_actual, **req_args)
                else:
                    resp = requests.request(metodo_real, url_actual, **req_args)
            except Exception as e:
                if not silent:
                    print(f"{Fore.RED}[!] Error al conectarse: {e}{Style.RESET_ALL}")
                continue

            # Detección diferencial (comparar con usuario legítimo si se provee)
            diff_alert = ""
            if legit_user_headers:
                try:
                    legit_args = req_args.copy()
                    legit_args["headers"] = legit_user_headers
                    if legit_user_body:
                        legit_args["data"] = legit_user_body
                    legit_resp = requests.request(metodo_real, url_actual, **legit_args)
                    if not respuestas_similares(resp, legit_resp):
                        diff_alert = " [DIFERENCIAL!]"
                except Exception:
                    pass

            # Heurísticas para detectar posible IDOR
            if resp.status_code == 200 and contiene_datos_sensibles(resp):
                if not silent:
                    print(f"{Fore.GREEN}[IDOR] Acceso exitoso: {url_actual} [{resp.status_code}]{diff_alert}{Style.RESET_ALL}")
                    print(f"{Fore.MAGENTA}Headers respuesta: {dict(resp.headers)}{Style.RESET_ALL}")
                guardar_resultado(output, f"[IDOR] {url_actual} [{resp.status_code}]{diff_alert}")
                if guardar_respuesta:
                    guardar_resultado(output, f"--- RESPUESTA COMPLETA ---\n{resp.text}\n")
                hallazgos.append(url_actual)
            elif resp.status_code in [403, 401]:
                if not silent:
                    print(f"{Fore.CYAN}[-] Acceso denegado: {url_actual} [{resp.status_code}]{Style.RESET_ALL}")
            elif resp.is_redirect:
                if not silent:
                    print(f"{Fore.YELLOW}[?] Redirección detectada: {url_actual} [{resp.status_code}] -> {resp.headers.get('Location', '')}{Style.RESET_ALL}")
            elif contiene_bypass(resp):
                if not silent:
                    print(f"{Fore.LIGHTYELLOW_EX}[!] Posible bypass detectado: {url_actual} [{resp.status_code}]{Style.RESET_ALL}")
                guardar_resultado(output, f"[BYPASS] {url_actual} [{resp.status_code}]")
            else:
                if not silent:
                    print(f"{Fore.YELLOW}[?] Resultado incierto: {url_actual} [{resp.status_code}]{Style.RESET_ALL}")
            # Guardar log detallado
            logs.append(f"[LOG] {url_actual} [{resp.status_code}] {resp.text[:200]}...")
            if output:
                guardar_resultado(output, logs[-1])
            break # si fue exitoso, no reintentar

    # Resumen final
    if not silent:
        print(f"{Fore.BLUE}--- Resumen: {len(hallazgos)} posibles IDOR detectados ---{Style.RESET_ALL}")
        for h in hallazgos:
            print(f"{Fore.GREEN}[IDOR] {h}{Style.RESET_ALL}")

def contiene_datos_sensibles(resp):
    # Soporta tanto texto como JSON
    contenido = resp.text
    patrones = [
        r'"id"\s*:\s*\d{2,}', r'"email"\s*:\s*".+?"', r'"username"\s*:\s*".+?"',
        r'"name"\s*:\s*".+?"', r'"token"\s*:\s*".+?"', r'"password"', r'"access_token"',
        r"Authorization", r"Set-Cookie", r"<input.+?value=.+?>", r"session", r"csrf",
        r'"role"\s*:\s*".+?"', r'"admin"\s*:\s*true', r'"credit_card"', r'"ssn"', r'"phone"',
        r'"address"', r'"dob"', r'"secret"', r'"apikey"', r'"api_key"', r'"refresh_token"',
        r'"private_key"', r'"secret_key"', r'"jwt"', r'"refresh_token"', r'"pin"', r'"iban"', r'"bic"', r'"passport"',
        r'"document"', r'"medical"', r'"insurance"', r'"ssn"', r'"tax"', r'"salary"', r'"balance"', r'"account"',
        r'"user_id"', r'"account_id"', r'"customer_id"', r'"profile_id"', r'"member_id"', r'"order_id"',
        r'"invoice_id"', r'"payment_id"', r'"transaction_id"', r'"card_number"', r'"cvv"', r'"exp_date"',
        r'"routing_number"', r'"bank_account"', r'"driver_license"', r'"license_plate"', r'"mac_address"',
        r'"ip_address"', r'"device_id"', r'"serial_number"', r'"imei"', r'"imsi"', r'"puk"', r'"pincode"',
        r'"medical_record"', r'"insurance_number"', r'"policy_number"', r'"passport_number"', r'"national_id"',
        r'"student_id"', r'"employee_id"', r'"tax_id"', r'"ssn"', r'"sin"', r'"nif"', r'"cif"', r'"nip"',
        r'"rfc"', r'"curp"', r'"clabe"', r'"cbu"', r'"cvu"', r'"nss"', r'"nis"', r'"nhs"', r'"nhc"',
        r'"mrn"', r'"ehr"', r'"ehr_id"', r'"insurance_id"', r'"beneficiary_id"', r'"dependent_id"',
        r'"parent_id"', r'"child_id"', r'"guardian_id"', r'"spouse_id"', r'"partner_id"', r'"relative_id"',
        r'"emergency_contact"', r'"next_of_kin"', r'"referrer_id"', r'"affiliate_id"', r'"sponsor_id"',
        r'"upline_id"', r'"downline_id"', r'"network_id"', r'"group_id"', r'"team_id"', r'"division_id"',
        r'"department_id"', r'"branch_id"', r'"location_id"', r'"site_id"', r'"building_id"', r'"room_id"',
        r'"bed_id"', r'"seat_id"', r'"ticket_id"', r'"reservation_id"', r'"booking_id"', r'"confirmation_id"',
        r'"reference_id"', r'"tracking_id"', r'"shipment_id"', r'"parcel_id"', r'"package_id"', r'"box_id"',
        r'"container_id"', r'"lot_id"', r'"batch_id"', r'"serial_id"', r'"asset_id"', r'"inventory_id"',
        r'"sku"', r'"product_id"', r'"item_id"', r'"goods_id"', r'"material_id"', r'"component_id"',
        r'"part_id"', r'"element_id"', r'"resource_id"', r'"tool_id"', r'"equipment_id"', r'"vehicle_id"',
        r'"machine_id"', r'"device_id"', r'"hardware_id"', r'"software_id"', r'"license_id"', r'"subscription_id"',
        r'"plan_id"', r'"service_id"', r'"contract_id"', r'"agreement_id"', r'"policy_id"', r'"claim_id"',
        r'"case_id"', r'"incident_id"', r'"event_id"', r'"activity_id"', r'"task_id"', r'"project_id"',
        r'"milestone_id"', r'"goal_id"', r'"objective_id"', r'"target_id"', r'"metric_id"', r'"indicator_id"',
        r'"score_id"', r'"grade_id"', r'"result_id"', r'"outcome_id"', r'"assessment_id"', r'"evaluation_id"',
        r'"review_id"', r'"feedback_id"', r'"comment_id"', r'"note_id"', r'"message_id"', r'"post_id"',
        r'"thread_id"', r'"forum_id"', r'"board_id"', r'"channel_id"', r'"group_id"', r'"community_id"',
        r'"organization_id"', r'"company_id"', r'"business_id"', r'"vendor_id"', r'"supplier_id"',
        r'"provider_id"', r'"client_id"', r'"customer_id"', r'"user_id"', r'"admin_id"', r'"moderator_id"',
        r'"staff_id"', r'"employee_id"', r'"manager_id"', r'"director_id"', r'"executive_id"', r'"officer_id"',
        r'"agent_id"', r'"representative_id"', r'"consultant_id"', r'"advisor_id"', r'"coach_id"',
        r'"trainer_id"', r'"teacher_id"', r'"instructor_id"', r'"professor_id"', r'"student_id"',
        r'"learner_id"', r'"participant_id"', r'"attendee_id"', r'"member_id"', r'"subscriber_id"',
        r'"follower_id"', r'"fan_id"', r'"supporter_id"', r'"donor_id"', r'"volunteer_id"', r'"contributor_id"',
        r'"author_id"', r'"editor_id"', r'"reviewer_id"', r'"approver_id"', r'"signer_id"', r'"witness_id"',
        r'"notary_id"', r'"registrar_id"', r'"inspector_id"', r'"auditor_id"', r'"controller_id"',
        r'"supervisor_id"', r'"coordinator_id"', r'"leader_id"', r'"chief_id"', r'"head_id"', r'"principal_id"',
        r'"dean_id"', r'"president_id"', r'"chair_id"', r'"secretary_id"', r'"treasurer_id"', r'"cashier_id"',
        r'"accountant_id"', r'"bookkeeper_id"', r'"payroll_id"', r'"hr_id"', r'"it_id"', r'"security_id"',
        r'"safety_id"', r'"compliance_id"', r'"legal_id"', r'"lawyer_id"', r'"attorney_id"', r'"judge_id"',
        r'"prosecutor_id"', r'"defender_id"', r'"plaintiff_id"', r'"defendant_id"', r'"victim_id"',
        r'"suspect_id"', r'"offender_id"', r'"criminal_id"', r'"prisoner_id"', r'"inmate_id"', r'"detainee_id"',
        r'"patient_id"', r'"doctor_id"', r'"nurse_id"', r'"therapist_id"', r'"counselor_id"', r'"psychologist_id"',
        r'"psychiatrist_id"', r'"pharmacist_id"', r'"dentist_id"', r'"optometrist_id"', r'"veterinarian_id"',
        r'"animal_id"', r'"pet_id"', r'"species_id"', r'"breed_id"', r'"plant_id"', r'"tree_id"', r'"crop_id"',
        r'"field_id"', r'"farm_id"', r'"garden_id"', r'"park_id"', r'"forest_id"', r'"lake_id"', r'"river_id"',
        r'"mountain_id"', r'"hill_id"', r'"valley_id"', r'"island_id"', r'"beach_id"', r'"coast_id"',
        r'"zone_id"', r'"area_id"', r'"region_id"', r'"district_id"', r'"province_id"', r'"state_id"',
        r'"country_id"', r'"continent_id"', r'"planet_id"', r'"star_id"', r'"galaxy_id"', r'"universe_id"'
    ]
    # Si es JSON, buscar claves sensibles
    try:
        data = resp.json()
        claves_sensibles = [
            "id", "email", "username", "name", "token", "password", "access_token", "role", "admin",
            "credit_card", "ssn", "phone", "address", "dob", "secret", "apikey", "api_key", "refresh_token",
            "private_key", "secret_key", "jwt", "refresh_token", "pin", "iban", "bic", "passport",
            "document", "medical", "insurance", "tax", "salary", "balance", "account",
            "user_id", "account_id", "customer_id", "profile_id", "member_id", "order_id",
            "invoice_id", "payment_id", "transaction_id", "card_number", "cvv", "exp_date",
            "routing_number", "bank_account", "driver_license", "license_plate", "mac_address",
            "ip_address", "device_id", "serial_number", "imei", "imsi", "puk", "pincode",
            "medical_record", "insurance_number", "policy_number", "passport_number", "national_id",
            "student_id", "employee_id", "tax_id", "ssn", "sin", "nif", "cif", "nip",
            "rfc", "curp", "clabe", "cbu", "cvu", "nss", "nis", "nhs", "nhc",
            "mrn", "ehr", "ehr_id", "insurance_id", "beneficiary_id", "dependent_id",
            "parent_id", "child_id", "guardian_id", "spouse_id", "partner_id", "relative_id",
            "emergency_contact", "next_of_kin", "referrer_id", "affiliate_id", "sponsor_id",
            "upline_id", "downline_id", "network_id", "group_id", "team_id", "division_id",
            "department_id", "branch_id", "location_id", "site_id", "building_id", "room_id",
            "bed_id", "seat_id", "ticket_id", "reservation_id", "booking_id", "confirmation_id",
            "reference_id", "tracking_id", "shipment_id", "parcel_id", "package_id", "box_id",
            "container_id", "lot_id", "batch_id", "serial_id", "asset_id", "inventory_id",
            "sku", "product_id", "item_id", "goods_id", "material_id", "component_id",
            "part_id", "element_id", "resource_id", "tool_id", "equipment_id", "vehicle_id",
            "machine_id", "device_id", "hardware_id", "software_id", "license_id", "subscription_id",
            "plan_id", "service_id", "contract_id", "agreement_id", "policy_id", "claim_id",
            "case_id", "incident_id", "event_id", "activity_id", "task_id", "project_id",
            "milestone_id", "goal_id", "objective_id", "target_id", "metric_id", "indicator_id",
            "score_id", "grade_id", "result_id", "outcome_id", "assessment_id", "evaluation_id",
            "review_id", "feedback_id", "comment_id", "note_id", "message_id", "post_id",
            "thread_id", "forum_id", "board_id", "channel_id", "group_id", "community_id",
            "organization_id", "company_id", "business_id", "vendor_id", "supplier_id",
            "provider_id", "client_id", "customer_id", "user_id", "admin_id", "moderator_id",
            "staff_id", "employee_id", "manager_id", "director_id", "executive_id", "officer_id",
            "agent_id", "representative_id", "consultant_id", "advisor_id", "coach_id",
            "trainer_id", "teacher_id", "instructor_id", "professor_id", "student_id",
            "learner_id", "participant_id", "attendee_id", "member_id", "subscriber_id",
            "follower_id", "fan_id", "supporter_id", "donor_id", "volunteer_id", "contributor_id",
            "author_id", "editor_id", "reviewer_id", "approver_id", "signer_id", "witness_id",
            "notary_id", "registrar_id", "inspector_id", "auditor_id", "controller_id",
            "supervisor_id", "coordinator_id", "leader_id", "chief_id", "head_id", "principal_id",
            "dean_id", "president_id", "chair_id", "secretary_id", "treasurer_id", "cashier_id",
            "accountant_id", "bookkeeper_id", "payroll_id", "hr_id", "it_id", "security_id",
            "safety_id", "compliance_id", "legal_id", "lawyer_id", "attorney_id", "judge_id",
            "prosecutor_id", "defender_id", "plaintiff_id", "defendant_id", "victim_id",
            "suspect_id", "offender_id", "criminal_id", "prisoner_id", "inmate_id", "detainee_id",
            "patient_id", "doctor_id", "nurse_id", "therapist_id", "counselor_id", "psychologist_id",
            "psychiatrist_id", "pharmacist_id", "dentist_id", "optometrist_id", "veterinarian_id",
            "animal_id", "pet_id", "species_id", "breed_id", "plant_id", "tree_id", "crop_id",
            "field_id", "farm_id", "garden_id", "park_id", "forest_id", "lake_id", "river_id",
            "mountain_id", "hill_id", "valley_id", "island_id", "beach_id", "coast_id",
            "zone_id", "area_id", "region_id", "district_id", "province_id", "state_id",
            "country_id", "continent_id", "planet_id", "star_id", "galaxy_id", "universe_id"
        ]
    except Exception:
        pass
    for patron in patrones:
        if re.search(patron, contenido, re.IGNORECASE):
            return True
    # Detección de leaks en headers
    for k, v in resp.headers.items():
        if re.search(r"token|key|session|auth|cookie|jwt|secret|id|account|user|email|password|apikey|api_key|refresh_token|private_key|secret_key", k, re.IGNORECASE):
            return True
    return False

def contiene_bypass(resp):
    # Detecta patrones de bypass comunes en la respuesta
    patrones = [
        r"bypass", r"unauthorized access granted", r"admin access", r"privilege escalation",
        r"access granted", r"successfully authenticated", r"token generated", r"root access",
        r"superuser", r"elevated privileges", r"full control", r"session hijacked", r"impersonation",
        r"escalated", r"privilege obtained", r"role changed", r"permission granted", r"security bypassed",
        r"authentication bypassed", r"authorization bypassed", r"access without login", r"direct access",
        r"forced browsing", r"directory traversal", r"file inclusion", r"shell access", r"command executed",
        r"exploit successful", r"exploit completed", r"exploit worked", r"exploit finished", r"exploit result"
    ]
    for patron in patrones:
        if re.search(patron, resp.text, re.IGNORECASE):
            return True
    return False

def respuestas_similares(resp1, resp2):
    # Compara tamaño y patrones clave para detectar diferencias
    if abs(len(resp1.text) - len(resp2.text)) > 50:
        return False
    patrones = [
        r"id", r"email", r"username", r"token", r"role", r"admin", r"session", r"account", r"user",
        r"balance", r"credit_card", r"ssn", r"phone", r"address", r"dob", r"secret", r"apikey",
        r"api_key", r"refresh_token", r"private_key", r"secret_key", r"jwt", r"passport", r"medical",
        r"insurance", r"salary", r"document", r"transaction", r"invoice", r"payment", r"order",
        r"customer", r"profile", r"member", r"employee", r"staff", r"manager", r"director", r"executive"
    ]
    for patron in patrones:
        if re.search(patron, resp1.text, re.IGNORECASE) != re.search(patron, resp2.text, re.IGNORECASE):
            return False
    return True